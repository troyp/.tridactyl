#!/bin/bash

# ───────────────────────────────────────────────────────────────────────────────
# ╭────────────╮
# │            │
# │  KWSEARCH  │
# │            │
# ╰────────────╯

# ╭───────────╮
# │ variables │
# ╰───────────╯
unset kw

# selection vars
filter=
kwonly=
# rofi vars
rofi=
rofithemestr='#window {width: 80%;} #listview {lines: 25;}';
multi=
# output vars
args=
oformat=
oneline=
yank=

# ╭─────────╮
# │ options │
# ╰─────────╯
SHORT="h,f:,j,J,k,K:,m,s,S,t,u,w,y,Y,1"
LONG="help,filter:,json,js-only,keyword-only,find-keyword:,multi-select,select,select-keyword,tridactyl,url,kw,yank,
  yank-only,one-line"
PARSED=$(getopt -a -n kwsearch --options "$SHORT" --longoptions "$LONG" -- "$@")

eval set -- "$PARSED"

while :
do
    case "$1" in
        (-h | --help)
            cat <<EOF
USAGE: kwsearch [OPTION...]
       kwsearch [-k] [-m|-s] [-y] [SEARCHTERM...]
       kwsearch [-K KW] [-y] [SEARCHTERM...]
    Access keyword (and other) bookmarks from bookmarks.json file. The bookmarks
    file can specified with the environment variable BMARKFILE.
    If SEARCHTERMs are specified, resolve search bookmarks by replacing %s with
    the SEARCHTERMs (escaping not yet supported).

Options:
  -f RE  --filter RE          filter bookmarks with RE
  -h     --help               show help
  -j     --json               force JSON output
  -J     --js-only            javascript: URI (bookmarklets) only
  -k     --keyword-only       keyword bookmarks only
  -K KW  --find-keyword KW    find bookmark with keyword KW
  -m     --multi-select       choose multiple bookmarks with Rofi
  -s     --select             choose bookmark with Rofi
  -S     --select-keyword     choose bookmark keyword with Rofi (implies --keyword-only)
  -t     --tridactyl          format as tridactyl searchurl setting (implies --keyword-only)
  -u     --url                print URL only
  -w     --kw                 print keyword only (implies --keyword-only)
  -y     --yank               copy output to clipboard
  -Y     --yank-only          send output to clipboard, no output
  -1     --one-line           display output on a single line
EOF
            exit 0
            ;;
        (-f | --filter) filter="$2"; shift 2; ;;
        (-j | --json) oformat=json; shift; ;;
        (-J | --js-only) jsonly=t; shift; ;;
        (-k | --keyword-only) kwonly=t; shift; ;;
        (-K | --find-keyword) kw="$2"; shift 2; ;;
        (-m | --multi-select) rofi=t; multi="-multi-select"; shift; ;;
        (-s | --select) rofi=t; shift; ;;
        (-S | --select-keyword) kwonly=t; rofi=kw; shift; ;;
        (-t | --tridactyl) oformat=tri; kwonly=t; shift; ;;
        (-u | --url) oformat=url; shift; ;;
        (-w | --kw) oformat=kw; kwonly=t; shift; ;;
        (-y | --yank) yank=t; shift; ;;
        (-Y | --yank-only) yank=only; shift; ;;
        (-1 | --one-line) oneline=t; shift; ;;
        (--) shift; break ;;
        (*)  echo "unrecognized option: $1" >&2 ; exit 1; ;;
    esac
done

# handle additional arguments
if [[ $# -gt 0 ]]; then args=t; fi;

# output format defaults to url when -K or arguments
if [[ -n $kw$args ]]; then oformat=${oformat:-url}; fi;

# ╭──────────────╮
# │ dependencies │
# ╰──────────────╯
# is grep -P supported? If not, use grep -E
RETYPE=$(echo | grep -P "" &>/dev/null && printf P || printf E);
# env var for yank command
KWSEARCH_YANKCMD=${KWSEARCH_YANKCMD:-xsel -ib};

# ╭─────────────────────────╮
# │ non-interactive filters │
# ╰─────────────────────────╯
bmarksjson=`mktemp`;

jq -rc '
   recurse(.children[]?)
   | select(.uri)
   | {keyword, title, uri}
' "${BMARKFILE:-$HOME/bookmarks/bookmarks.json}" | {
    # --keyword-only
    if [[ -n $kwonly ]]; then
        jq -c 'select(.keyword)';
    else cat;
    fi;
} | {
    # javascript: URI only
    if [[ -n $jsonly ]]; then
        jq -c 'select(.uri | test("^javascript:"))';
    else cat;
    fi;
} | {
    # select by --find-keyword ?
    if [[ -n ${kw+SET} ]]; then
        jq -c "select(.keyword == \"$kw\")";
    else {
        # filter results
        # filter with regex
        if [[ -n filter ]]; then grep -i -$RETYPE "$filter";
        else cat;
        fi;
    }
    fi
} > $bmarksjson;

# ╭────────────────╮
# │ rofi selection │
# ╰────────────────╯
lines=`mktemp`;

if [[ -n $rofi ]]; then
    cat $bmarksjson |
        perl -pe 's/{"keyword":(null|"(.*)"),"title":"(.*)","uri":"(.*)"}/
                    sprintf("%-18s \t%s  (<%s>)","$2:",$3,$4)/e' |
        if [[ $rofi == kw ]]; then
            # keyword completion with rofi
            rofi -theme-str "$rofithemestr" -dmenu -i -no-custom -matching "regex" -format d -filter "^" $multi;
        else
            rofi -theme-str "$rofithemestr" -dmenu -i -no-custom -matching "regex" -format d $multi;
        fi > $lines;
fi;

# ╭────────╮
# │ output │
# ╰────────╯

if [[ -n $rofi ]]; then
    sed -n -f <(sed 's/$/p/' $lines) $bmarksjson;
else
    cat $bmarksjson;
fi |

    # output format
    case $oformat in
        url) jq -r '.uri'; ;;
        kw)  jq -r '.keyword'; ;;
        tri) perl -pe 's/{"keyword":"(.*)","title":"(.*)","uri":"(.*)"}/set searchurls.$1 $3/'; ;;
        json | *) cat; ;;
    esac |

    # arguments: resolve search bookmark URLs
    if [[ -n $args ]]; then
        # TODO: handle | in arguments
        # TODO: handle escaping in search URL
        s=$(printf %s "$*" | jq -sRr @uri);
        S=${*//&/\\&}
        sed "s|%S|$S|" | sed "s|%s|$s|";
    else
        cat;
    fi |

    # single-line?
    if [[ -n $oneline ]]; then
        tr "\n" " " | sed -r 's/ +$//';
    else
        cat;
    fi |

    # yank?
    if [[ $yank == only ]]; then
        $KWSEARCH_YANKCMD;
    elif [[ -n $yank ]]; then
        tee >($KWSEARCH_YANKCMD);
    else
        cat;
    fi;
